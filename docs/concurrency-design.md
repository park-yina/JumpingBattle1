# Concurrency Design

## 1. 문제 상황

랭킹 업데이트 도중, 특정 시점에서
랭킹 화면이 순간적으로 비어 보이는 현상이 발생했습니다.

- 새로고침 시 정상 출력
- 서버 에러 로그 없음
- 특정 피크 시간대에만 간헐적 발생

일시적인 화면 공백 현상은 재요청 시 정상적으로 복구되었으며,
지속적인 데이터 손상은 발생하지 않았습니다.

이를 통해 일관성 문제보다는
**동시성 문제(Race Condition)** 가능성을 의심하게 되었습니다.

---

## 2. 초기 랭킹 구조

초기 랭킹 시스템은 다음과 같은 구조였습니다:

1. Firestore 변경 발생
2. 서버에서 점수 반영
3. 랭킹 리스트 정렬
4. 서버 전역 캐시에 저장
5. 클라이언트는 해당 캐시를 조회

정렬은 요청마다 수행하지 않고,
**업데이트 시점에만 수행**하도록 설계되어 있었습니다.

클라이언트 요청 시에는
이미 정렬된 서버 캐시를 그대로 반환하는 구조였습니다.

---
## 3. 원인 분석

랭킹 캐시는 `state.py` 모듈에 정의되어 있었습니다.
이는 순환 참조를 방지하고 전역 상태를 명확히 관리하기 위해
의도적으로 분리한 구조였습니다.

그러나 이 구조는 동시에 모든 스레드가 접근 가능한
전역 힙 객체를 생성하는 결과를 낳았습니다.

각 스레드는 독립적인 스택을 가지지만,
전역 변수는 힙 영역에 존재하므로
동기화 없이 접근할 경우 동시성 문제가 발생할 수 있습니다.

즉, 해당 랭킹 캐시는 여러 스레드가 동시에 접근 가능한
**공유 자원(shared resource)** 이었습니다.

다음과 같은 스레드가 동일 캐시에 접근하고 있었습니다:

- Firestore listener thread
- HTTP 요청 처리 thread
- 내부 랭킹 갱신 로직

동기화 없이 전역 dict에 쓰기가 발생하면서 다음과 같은 상황이 가능했습니다:

1. Thread A가 랭킹을 정렬 중
2. Thread B가 동일한 캐시에 접근
3. 정렬 중간 상태가 외부 요청에 노출
4. 일부 데이터 누락 또는 빈 화면 발생

Python의 dict는 개별 연산은 원자적으로 동작하지만,
여러 연산이 결합된 전체 로직이
멀티스레드 환경에서 안전함을 보장하지는 않습니다.

특히 쓰기 도중에는 중간 상태가 노출될 수 있으며,
이로 인해 캐시 갱신 구간이 명확히 보호되어야 할
**임계 구역(Critical Section)** 임을 인지하게 되었습니다.

## 4. 해결 방법

랭킹 갱신 및 캐시 업데이트 구간을
임계 구역으로 정의하고 `threading.Lock`을 도입했습니다.

```python
import threading

cache_lock = threading.Lock()

def update_ranking():
    with cache_lock:
        # 1. 점수 반영
        # 2. rank_list 재정렬
        # 3. store_rank_cache 갱신

랭킹 데이터는 전역 메모리 캐시에 저장되어 있었습니다:
